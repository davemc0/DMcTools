// DO NOT COMPILE THIS FILE!!!
// IT IS #included in BisonMe.cpp!!!

/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /hosts/bonnie.engr.sgi.com/proj/irix6.5/isms/eoe/cmd/flex/flex-2.5.4/RCS/skel.c,v 1.3 1998/04/17 16:09:54 leedom Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>

/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifdef __cplusplus

#include <stdlib.h>
#ifndef DMC_MACHINE_win
#include <unistd.h>
#endif

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif /* __STDC__ */
#endif /* ! __cplusplus */

#ifdef __TURBOC__
#pragma warn - rch
#pragma warn - use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int)(unsigned char)c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state* YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *  if ( condition_holds )
 *      yyless( 5 );
 *  else
 *      do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n)                                      \
    do {                                               \
        /* Undo effects of setting up yytext. */       \
        *yy_cp = yy_hold_char;                         \
        YY_RESTORE_YY_MORE_OFFSET                      \
        yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ;  \
        YY_DO_BEFORE_ACTION; /* set up yytext again */ \
    } while (0)

#define unput(c) yyunput(c, yytext_ptr)

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;

struct yy_buffer_state {
    FILE* yy_input_file;

    char* yy_ch_buf;  /* input buffer */
    char* yy_buf_pos; /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    yy_size_t yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
    /* When an EOF's been seen but there's still some text to process
     * then we mark the buffer as YY_EOF_PENDING, to indicate that we
     * shouldn't try reading from the input source any more.  We might
     * still have a bunch of tokens to match, though, because of
     * possible backing-up.
     *
     * When we actually see the EOF, we change the status to "new"
     * (via yyrestart()), so that the user can continue scanning by
     * just pointing yyin at a new input file.
     */
#define YY_BUFFER_EOF_PENDING 2
};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars; /* number of characters read into yy_ch_buf */

int yyleng;

/* Points to current character in buffer. */
static char* yy_c_buf_p = (char*)0;
static int yy_init = 1;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO((FILE * input_file));

void yy_switch_to_buffer YY_PROTO((YY_BUFFER_STATE new_buffer));
void yy_load_buffer_state YY_PROTO((void));
YY_BUFFER_STATE yy_create_buffer YY_PROTO((FILE * file, int size));
void yy_delete_buffer YY_PROTO((YY_BUFFER_STATE b));
void yy_init_buffer YY_PROTO((YY_BUFFER_STATE b, FILE* file));
void yy_flush_buffer YY_PROTO((YY_BUFFER_STATE b));
#define YY_FLUSH_BUFFER yy_flush_buffer(yy_current_buffer)

YY_BUFFER_STATE yy_scan_buffer YY_PROTO((char* base, yy_size_t size));
YY_BUFFER_STATE yy_scan_string YY_PROTO((yyconst char* yy_str));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO((yyconst char* bytes, int len));

static void* yy_flex_alloc YY_PROTO((yy_size_t));
static void* yy_flex_realloc YY_PROTO((void*, yy_size_t));
static void yy_flex_free YY_PROTO((void*));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive)                                               \
    {                                                                                    \
        if (!yy_current_buffer) yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE); \
        yy_current_buffer->yy_is_interactive = is_interactive;                           \
    }

#define yy_set_bol(at_bol)                                                               \
    {                                                                                    \
        if (!yy_current_buffer) yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE); \
        yy_current_buffer->yy_at_bol = at_bol;                                           \
    }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

typedef unsigned char YY_CHAR;
FILE *yyin = (FILE*)0, *yyout = (FILE*)0;
typedef int yy_state_type;
extern char* yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO((void));
static yy_state_type yy_try_NUL_trans YY_PROTO((yy_state_type current_state));
static int yy_get_next_buffer YY_PROTO((void));
static void yy_fatal_error YY_PROTO((yyconst char msg[]));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION        \
    yytext_ptr = yy_bp;            \
    yyleng = (int)(yy_cp - yy_bp); \
    yy_hold_char = *yy_cp;         \
    *yy_cp = '\0';                 \
    yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 109
#define YY_END_OF_BUFFER 110
static yyconst short int yy_accept[825] = {
    0,   0,   0,   110, 108, 1,   2,   108, 108, 107, 108, 106, 107, 108, 102, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 1,   0,   105, 104, 0,
    3,   107, 0,   102, 102, 103, 103, 0,   107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 48,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,

    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 85,  107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,
    107, 107, 107, 107, 103, 0,   103, 107, 107, 107, 107, 107, 107, 107, 107, 107, 4,   107, 107, 107, 107, 107, 107, 107, 107, 49,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 10,  107, 107, 107, 107, 107, 107, 107, 107, 107, 107,

    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 103, 0,   50,  107, 107, 107, 107, 107, 107, 74,  107, 107,
    107, 107, 107, 12,  107, 107, 11,  107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 51,  107, 107, 107, 107, 107, 107,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 9,   107, 107, 107, 107,
    107, 107, 101, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 0,   103, 107, 107, 107,

    107, 107, 107, 107, 107, 52,  6,   107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 32,  39,  107, 107, 107, 107, 107, 107,
    107, 99,  107, 107, 81,  107, 107, 107, 77,  107, 107, 107, 107, 107, 107, 107, 107, 93,  107, 107, 107, 107, 107, 107, 107, 107,
    107, 58,  107, 107, 107, 107, 91,  107, 107, 107, 107, 107, 107, 107, 21,  107, 107, 75,  107, 107, 107, 35,  107, 107, 107, 107,
    107, 107, 107, 55,  107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 46,

    107, 107, 107, 107, 107, 107, 107, 107, 92,  107, 107, 76,  107, 100, 107, 107, 38,  107, 107, 107, 107, 73,  107, 107, 107, 107,
    107, 107, 107, 13,  107, 107, 107, 56,  107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 22,  107, 107, 107, 107, 107,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 72,  107, 107,

    59,  107, 107, 23,  107, 107, 107, 107, 41,  107, 107, 107, 107, 53,  107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,
    107, 34,  54,  107, 107, 107, 84,  107, 107, 107, 107, 15,  107, 42,  107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 30,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 5,   107, 80,  107, 107, 107, 107, 107, 8,   107, 107, 107,
    107, 107, 83,  107, 107, 107, 107, 82,  107, 107, 107, 107, 107, 107, 31,  64,  107, 95,  107, 107, 107, 107,

    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 25,  107, 79,  107, 107, 107, 27,  107, 107, 107, 107, 107, 107, 68,  107,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 57,  107, 107, 107, 107,
    107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 43,  107, 107, 36,  87,  107, 86,  107, 107, 18,  107, 70,  16,  96,  107, 40,
    107, 107, 44,  107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,

    107, 107, 60,  63,  107, 107, 107, 107, 107, 107, 65,  107, 107, 107, 107, 107, 107, 107, 107, 107, 20,  107, 107, 107, 107, 107,
    107, 107, 107, 107, 107, 62,  17,  69,  47,  61,  107, 107, 107, 107, 107, 107, 107, 67,  107, 107, 107, 107, 107, 107, 107, 107,
    107, 107, 107, 107, 107, 28,  107, 107, 107, 107, 107, 19,  37,  107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,
    107, 29,  78,  24,  107, 107, 107, 107, 90,  107, 107, 107, 107, 107, 98,  107, 107, 107, 14,  107, 107, 45,

    107, 107, 107, 71,  107, 107, 26,  107, 107, 66,  7,   33,  107, 107, 97,  88,  107, 107, 107, 107, 107, 94,  89,  0};

static yyconst int yy_ec[256] = {0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
                                 1,  1,  1,  1,  2,  1,  4,  5,  1,  1,  1,  1,  6,  6,  1,  7,  8,  9,  10, 1,  11, 11, 12, 13, 11, 11, 11, 11,
                                 11, 11, 1,  1,  1,  1,  1,  1,  1,  14, 15, 16, 17, 18, 19, 20, 21, 22, 6,  23, 24, 25, 26, 27, 28, 6,  29, 30,
                                 31, 32, 33, 34, 35, 36, 6,  37, 1,  38, 1,  39, 1,  40, 41, 42, 43,

                                 44, 45, 46, 47, 48, 6,  49, 50, 51, 52, 53, 54, 6,  55, 56, 57, 58, 59, 60, 61, 62, 6,  63, 1,  64, 1,  1,  1,
                                 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
                                 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
                                 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

                                 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
                                 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1};

static yyconst int yy_meta[65] = {0, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                  2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1};

static yyconst short int yy_base[828] = {
    0,   0,   0,   906, 907, 903, 907, 62,  901, 0,   57,  907, 61,  64,  68,  50,  60,  67,  889, 847, 849, 860, 56,  67,  70,  846, 63,
    72,  872, 863, 41,  53,  76,  845, 81,  851, 842, 50,  853, 51,  44,  77,  88,  91,  82,  95,  844, 889, 139, 907, 886, 886, 907, 0,
    138, 142, 146, 149, 152, 159, 857, 836, 838, 858, 114, 831, 842, 832, 862, 825, 855, 825, 124, 820, 850, 820, 855, 0,   855, 843, 816,
    125, 813, 845, 828, 813, 826, 812, 832, 802, 822, 838, 826, 808, 817, 805, 94,  812, 798, 800, 129,

    800, 804, 809, 132, 808, 809, 800, 790, 794, 803, 121, 793, 788, 0,   794, 782, 129, 136, 788, 782, 798, 140, 139, 782, 775, 795, 784,
    145, 790, 185, 190, 193, 196, 805, 800, 779, 813, 795, 801, 771, 781, 776, 0,   779, 792, 763, 776, 766, 155, 800, 766, 0,   787, 776,
    758, 761, 764, 771, 788, 759, 768, 753, 749, 787, 747, 751, 776, 787, 756, 751, 741, 744, 741, 755, 767, 736, 747, 747, 736, 733, 744,
    737, 742, 745, 733, 737, 738, 735, 740, 0,   167, 735, 727, 733, 723, 723, 726, 725, 728, 728,

    730, 719, 714, 715, 724, 717, 716, 706, 710, 703, 703, 702, 701, 201, 204, 212, 0,   717, 716, 732, 736, 722, 709, 0,   699, 708, 731,
    694, 686, 0,   691, 697, 0,   704, 729, 199, 688, 684, 683, 682, 721, 693, 681, 691, 710, 0,   675, 676, 704, 678, 674, 684, 683, 671,
    682, 668, 678, 675, 663, 678, 692, 662, 686, 673, 663, 664, 669, 665, 659, 653, 652, 653, 659, 0,   666, 653, 647, 646, 645, 643, 0,
    656, 642, 654, 653, 648, 637, 642, 641, 634, 635, 646, 636, 644, 640, 215, 218, 631, 628, 650,

    648, 664, 633, 637, 622, 0,   0,   634, 629, 615, 625, 650, 659, 654, 627, 646, 621, 620, 0,   644, 626, 644, 616, 608, 188, 628, 619,
    0,   608, 604, 0,   636, 613, 611, 0,   599, 597, 608, 604, 589, 594, 609, 631, 0,   590, 590, 598, 596, 595, 581, 591, 583, 612, 0,
    590, 581, 581, 587, 615, 602, 580, 581, 586, 583, 573, 141, 0,   572, 565, 0,   579, 576, 601, 0,   593, 569, 576, 571, 575, 577, 585,
    600, 590, 597, 583, 569, 562, 556, 555, 563, 549, 557, 558, 559, 549, 561, 574, 552, 541, 0,

    545, 582, 581, 550, 545, 547, 532, 536, 0,   538, 540, 573, 538, 0,   532, 544, 0,   561, 542, 536, 527, 0,   563, 525, 537, 514, 531,
    534, 541, 0,   528, 531, 530, 0,   542, 524, 514, 536, 549, 524, 508, 509, 542, 510, 504, 510, 0,   539, 525, 498, 508, 501, 500, 489,
    497, 497, 501, 223, 492, 489, 506, 491, 527, 499, 489, 488, 523, 485, 508, 492, 491, 490, 477, 480, 474, 478, 479, 476, 470, 481, 473,
    466, 471, 480, 467, 464, 464, 462, 501, 459, 460, 459, 456, 460, 493, 486, 452, 0,   456, 467,

    491, 465, 452, 464, 484, 453, 453, 476, 475, 458, 441, 438, 437, 462, 439, 440, 442, 459, 433, 434, 442, 439, 438, 430, 430, 441, 464,
    0,   0,   422, 432, 415, 0,   454, 432, 426, 417, 0,   422, 0,   414, 426, 413, 452, 423, 413, 417, 420, 420, 423, 217, 0,   434, 416,
    419, 416, 409, 404, 412, 432, 418, 393, 394, 406, 405, 399, 0,   391, 0,   391, 392, 414, 390, 421, 0,   391, 379, 389, 388, 387, 0,
    379, 382, 394, 383, 0,   380, 387, 377, 385, 378, 374, 0,   0,   373, 0,   372, 371, 371, 378,

    372, 365, 362, 402, 404, 366, 371, 362, 357, 364, 385, 371, 365, 0,   346, 33,  62,  0,   180, 182, 196, 189, 228, 190, 0,   200, 201,
    193, 204, 199, 198, 207, 209, 192, 202, 198, 208, 202, 208, 204, 208, 219, 207, 206, 224, 203, 243, 0,   243, 238, 226, 225, 219, 255,
    251, 258, 236, 237, 216, 226, 236, 226, 0,   253, 227, 0,   0,   228, 0,   231, 243, 0,   242, 0,   0,   0,   235, 0,   235, 246, 0,
    228, 243, 231, 242, 244, 261, 248, 253, 250, 246, 254, 283, 276, 263, 255, 256, 267, 251, 260,

    269, 292, 0,   0,   256, 268, 252, 268, 260, 294, 0,   265, 279, 275, 276, 299, 276, 266, 272, 270, 0,   291, 310, 277, 272, 273, 289,
    287, 281, 279, 296, 0,   0,   0,   0,   0,   284, 291, 296, 283, 301, 311, 295, 0,   297, 293, 327, 328, 303, 287, 288, 297, 298, 312,
    313, 323, 312, 0,   303, 318, 309, 341, 303, 0,   0,   344, 327, 308, 325, 326, 315, 312, 311, 312, 334, 327, 321, 324, 317, 0,   0,
    0,   357, 336, 335, 336, 0,   328, 336, 328, 354, 322, 0,   327, 324, 369, 0,   334, 335, 0,

    377, 335, 373, 0,   331, 354, 0,   343, 344, 0,   0,   0,   357, 355, 0,   0,   356, 346, 347, 350, 351, 0,   0,   907, 402, 404, 405};

static yyconst short int yy_def[828] = {
    0,   824, 1,   824, 824, 824, 824, 825, 826, 827, 824, 824, 827, 824, 824, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 824, 825, 824, 824, 826, 824, 827,
    824, 824, 827, 824, 824, 824, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,

    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 824, 824, 824, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,

    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 824, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 824, 824, 827, 827, 827,

    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,

    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,

    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,

    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,

    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,
    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827,

    827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 827, 0,   824, 824, 824};

static yyconst short int yy_nxt[972] = {
    0,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  14,  14,  15,  9,   16,  17,  9,   18,  19,  9,   20,  9,   9,   21,
    22,  23,  24,  25,  26,  27,  28,  9,   29,  9,   9,   11,  11,  4,   30,  9,   31,  32,  33,  34,  9,   35,  36,  9,   37,  38,
    39,  40,  41,  42,  43,  44,  9,   45,  46,  9,   9,   11,  11,  49,  50,  54,  55,  55,  55,  54,  56,  56,  56,  57,  57,  57,
    58,  55,  55,  55,  60,  74,  63,  68,  76,  64,  79,  93,  83,  112, 94,  77,  109, 658, 114, 95,  61,  115, 78,

    88,  62,  110, 113, 84,  96,  85,  97,  75,  86,  98,  59,  65,  80,  69,  89,  87,  66,  659, 99,  103, 67,  81,  100, 116, 125,
    90,  118, 104, 117, 101, 119, 121, 105, 127, 106, 126, 122, 128, 138, 120, 49,  50,  172, 123, 139, 173, 124, 57,  57,  57,  58,
    55,  55,  55,  58,  56,  56,  56,  57,  57,  57,  131, 131, 131, 132, 147, 132, 148, 133, 133, 133, 156, 177, 190, 182, 196, 191,
    198, 203, 157, 183, 205, 178, 197, 59,  211, 204, 206, 130, 432, 132, 199, 214, 433, 215, 215, 215, 231, 212,

    131, 131, 131, 133, 133, 133, 133, 133, 133, 232, 272, 215, 215, 215, 215, 215, 215, 313, 296, 660, 296, 273, 297, 297, 297, 297,
    297, 297, 297, 297, 297, 314, 395, 216, 514, 602, 661, 396, 515, 662, 663, 664, 665, 666, 667, 668, 603, 669, 670, 671, 672, 673,
    674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699,
    700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721,

    722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747,
    748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773,
    774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799,
    800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821,

    822, 823, 48,  48,  51,  51,  53,  657, 656, 655, 654, 653, 652, 651, 650, 649, 648, 647, 646, 645, 644, 643, 642, 641, 640, 639,
    638, 637, 636, 635, 634, 633, 632, 631, 630, 629, 628, 627, 626, 625, 624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613,
    612, 611, 610, 609, 608, 607, 606, 605, 604, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591, 590, 589, 588, 587, 586, 585,
    584, 583, 582, 581, 580, 579, 578, 577, 576, 575, 574, 573, 572, 571, 570, 569, 568, 567, 566, 565, 564, 563,

    562, 561, 560, 559, 558, 557, 556, 555, 554, 553, 552, 551, 550, 549, 548, 547, 546, 545, 544, 543, 542, 541, 540, 539, 538, 537,
    536, 535, 534, 533, 532, 531, 530, 529, 528, 527, 526, 525, 524, 523, 522, 521, 520, 519, 518, 517, 516, 513, 512, 511, 510, 509,
    508, 507, 506, 505, 504, 503, 502, 501, 500, 499, 498, 497, 496, 495, 494, 493, 492, 491, 490, 489, 488, 487, 486, 485, 484, 483,
    482, 481, 480, 479, 478, 477, 476, 475, 474, 473, 472, 471, 470, 469, 468, 467, 466, 465, 464, 463, 462, 461,

    460, 459, 458, 457, 456, 455, 454, 453, 452, 451, 450, 449, 448, 447, 446, 445, 444, 443, 442, 441, 440, 439, 438, 437, 436, 435,
    434, 431, 430, 429, 428, 427, 426, 425, 424, 423, 422, 421, 420, 419, 418, 417, 416, 415, 414, 413, 412, 411, 410, 409, 408, 407,
    406, 405, 404, 403, 402, 401, 400, 399, 398, 397, 394, 393, 392, 391, 390, 389, 388, 387, 386, 385, 384, 383, 382, 381, 380, 379,
    378, 377, 376, 375, 374, 373, 372, 371, 370, 369, 368, 367, 366, 365, 364, 363, 362, 361, 360, 359, 358, 357,

    356, 355, 354, 353, 352, 351, 350, 349, 348, 347, 346, 345, 344, 343, 342, 341, 340, 339, 338, 337, 336, 335, 334, 333, 332, 331,
    330, 329, 328, 327, 326, 325, 324, 323, 322, 321, 320, 319, 318, 317, 316, 315, 312, 311, 310, 309, 308, 307, 306, 305, 304, 303,
    302, 301, 300, 299, 298, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275,
    274, 271, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254, 253, 252, 251,

    250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 230, 229, 228, 227, 226, 225, 224, 223,
    222, 221, 220, 219, 218, 217, 213, 210, 209, 208, 207, 202, 201, 200, 195, 194, 193, 192, 189, 188, 187, 186, 185, 184, 181, 180,
    179, 176, 175, 174, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 155, 154, 153, 152, 151, 150, 149, 146,
    145, 144, 143, 142, 141, 140, 137, 136, 135, 134, 52,  48,  47,  129, 111, 108, 107, 102, 92,  91,  82,  73,

    72,  71,  70,  52,  47,  824, 3,   824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824,
    824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824,
    824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824};

static yyconst short int yy_chk[972] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   7,   7,   10,  10,  10,  10,  12,  12,  12,  12,  13,  13,  13,
    14,  14,  14,  14,  15,  22,  16,  17,  23,  16,  24,  30,  26,  39,  30,  23,  37,  616, 40,  31,  15,  40,  23,

    27,  15,  37,  39,  26,  31,  26,  31,  22,  26,  31,  14,  16,  24,  17,  27,  26,  16,  617, 32,  34,  16,  24,  32,  41,  44,
    27,  42,  34,  41,  32,  42,  43,  34,  45,  34,  44,  43,  45,  64,  42,  48,  48,  96,  43,  64,  96,  43,  54,  54,  54,  55,
    55,  55,  55,  56,  56,  56,  56,  57,  57,  57,  58,  58,  58,  59,  72,  59,  72,  59,  59,  59,  81,  100, 111, 104, 117, 111,
    118, 122, 81,  104, 123, 100, 117, 55,  128, 122, 123, 56,  366, 130, 118, 130, 366, 130, 130, 130, 149, 128,

    131, 131, 131, 132, 132, 132, 133, 133, 133, 149, 191, 214, 214, 214, 215, 215, 215, 236, 216, 619, 216, 191, 216, 216, 216, 296,
    296, 296, 297, 297, 297, 236, 325, 131, 458, 551, 620, 325, 458, 621, 622, 623, 624, 626, 627, 628, 551, 629, 630, 631, 632, 633,
    634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660,
    661, 662, 664, 665, 668, 670, 671, 673, 677, 679, 680, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692,

    693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 705, 706, 707, 708, 709, 710, 712, 713, 714, 715, 716, 717, 718, 719, 720, 722,
    723, 724, 725, 726, 727, 728, 729, 730, 731, 737, 738, 739, 740, 741, 742, 743, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754,
    755, 756, 757, 759, 760, 761, 762, 763, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 783, 784, 785, 786,
    788, 789, 790, 791, 792, 794, 795, 796, 798, 799, 801, 802, 803, 805, 806, 808, 809, 813, 814, 817, 818, 819,

    820, 821, 825, 825, 826, 826, 827, 615, 613, 612, 611, 610, 609, 608, 607, 606, 605, 604, 603, 602, 601, 600, 599, 598, 597, 595,
    592, 591, 590, 589, 588, 587, 585, 584, 583, 582, 580, 579, 578, 577, 576, 574, 573, 572, 571, 570, 568, 566, 565, 564, 563, 562,
    561, 560, 559, 558, 557, 556, 555, 554, 553, 550, 549, 548, 547, 546, 545, 544, 543, 542, 541, 539, 537, 536, 535, 534, 532, 531,
    530, 527, 526, 525, 524, 523, 522, 521, 520, 519, 518, 517, 516, 515, 514, 513, 512, 511, 510, 509, 508, 507,

    506, 505, 504, 503, 502, 501, 500, 499, 497, 496, 495, 494, 493, 492, 491, 490, 489, 488, 487, 486, 485, 484, 483, 482, 481, 480,
    479, 478, 477, 476, 475, 474, 473, 472, 471, 470, 469, 468, 467, 466, 465, 464, 463, 462, 461, 460, 459, 457, 456, 455, 454, 453,
    452, 451, 450, 449, 448, 446, 445, 444, 443, 442, 441, 440, 439, 438, 437, 436, 435, 433, 432, 431, 429, 428, 427, 426, 425, 424,
    423, 421, 420, 419, 418, 416, 415, 413, 412, 411, 410, 408, 407, 406, 405, 404, 403, 402, 401, 399, 398, 397,

    396, 395, 394, 393, 392, 391, 390, 389, 388, 387, 386, 385, 384, 383, 382, 381, 380, 379, 378, 377, 376, 375, 373, 372, 371, 369,
    368, 365, 364, 363, 362, 361, 360, 359, 358, 357, 356, 355, 353, 352, 351, 350, 349, 348, 347, 346, 345, 343, 342, 341, 340, 339,
    338, 337, 336, 334, 333, 332, 330, 329, 327, 326, 324, 323, 322, 321, 320, 318, 317, 316, 315, 314, 313, 312, 311, 310, 309, 308,
    305, 304, 303, 302, 301, 300, 299, 298, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282,

    280, 279, 278, 277, 276, 275, 273, 272, 271, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254,
    253, 252, 251, 250, 249, 248, 247, 245, 244, 243, 242, 241, 240, 239, 238, 237, 235, 234, 232, 231, 229, 228, 227, 226, 225, 223,
    222, 221, 220, 219, 218, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193,
    192, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169,

    168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 151, 150, 148, 147, 146, 145, 144, 142, 141, 140,
    139, 138, 137, 136, 135, 134, 129, 127, 126, 125, 124, 121, 120, 119, 116, 115, 113, 112, 110, 109, 108, 107, 106, 105, 103, 102,
    101, 99,  98,  97,  95,  94,  93,  92,  91,  90,  89,  88,  87,  86,  85,  84,  83,  82,  80,  79,  78,  76,  75,  74,  73,  71,
    70,  69,  68,  67,  66,  65,  63,  62,  61,  60,  51,  50,  47,  46,  38,  36,  35,  33,  29,  28,  25,  21,

    20,  19,  18,  8,   5,   3,   824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824,
    824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824,
    824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 824};

static yy_state_type yy_last_accepting_state;
static char* yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char* yytext;
#line 1 "FlexMe.l"
#define INITIAL 0
/*** FlexMe.l ***/
#line 3 "FlexMe.l"
#include <Model/LoadVRML.h>

char* stripquotes(void);
char* stripunderscore(void);
int my_linecount = 2; /* Since we read the #VRML 1.0 line outside. */

/* also need to change value in fscanf */
#define LINE_MAXLEN 5120

/* the input file */
extern FILE* InFile;

/* New YY_INPUT to save input line (for error messages), and convert from
 * DOS format (\r\n) to Unix format (\n) as needed
 */
char my_linetext[LINE_MAXLEN];
#undef YY_INPUT
#define YY_INPUT(buf, result, max_size)                      \
    {                                                        \
        char* c;                                             \
        if (max_size < LINE_MAXLEN) {                        \
            fprintf(stderr, "** YY_INPUT: max_size err\n");  \
            exit(1);                                         \
        }                                                    \
        result = 0;                                          \
        buf[0] = '\0';                                       \
        c = fgets(buf, LINE_MAXLEN, InFile);                 \
        result = (int)strlen(buf);                           \
        if (c == 0) {                                        \
            result = YY_NULL;                                \
        } else {                                             \
            if ((result > 1) && (buf[result - 2] == '\r')) { \
                buf[result - 2] = '\n';                      \
                buf[result--] = '\0';                        \
            } else {                                         \
            }                                                \
            strcpy(my_linetext, buf);                        \
        }                                                    \
    }
#line 898 "lex.yy.c"

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO((void));
#else
extern int yywrap YY_PROTO((void));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO((int c, char* buf_ptr));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO((char*, yyconst char*, int));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO((yyconst char*));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO((void));
#else
static int input YY_PROTO((void));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int* yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO((int new_state));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO((void));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO((void));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void)fwrite(yytext, yyleng, 1, yyout)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                                          \
    if (yy_current_buffer->yy_is_interactive) {                                                  \
        int c = '*', n;                                                                          \
        for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n) buf[n] = (char)c; \
        if (c == '\n') buf[n++] = (char)c;                                                       \
        if (c == EOF && ferror(yyin)) YY_FATAL_ERROR("input in flex scanner failed");            \
        result = n;                                                                              \
    } else if (((result = fread(buf, 1, max_size, yyin)) == 0) && ferror(yyin))                  \
        YY_FATAL_ERROR("input in flex scanner failed");
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO((void))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP YY_USER_ACTION

YY_DECL
{
    register yy_state_type yy_current_state;
    register char *yy_cp, *yy_bp;
    register int yy_act;

#line 52 "FlexMe.l"

#line 1051 "lex.yy.c"

    if (yy_init) {
        yy_init = 0;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if (!yy_start) yy_start = 1; /* first start state */

        if (!yyin) yyin = stdin;

        if (!yyout) yyout = stdout;

        if (!yy_current_buffer) yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE);

        yy_load_buffer_state();
    }

    while (1) /* loops until end-of-file is reached */
    {
        yy_cp = yy_c_buf_p;

        /* Support of yytext. */
        *yy_cp = yy_hold_char;

        /* yy_bp points to the position in yy_ch_buf of the start of
         * the current run.
         */
        yy_bp = yy_cp;

        yy_current_state = yy_start;
    yy_match:
        do {
            register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
            if (yy_accept[yy_current_state]) {
                yy_last_accepting_state = yy_current_state;
                yy_last_accepting_cpos = yy_cp;
            }
            while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
                yy_current_state = (int)yy_def[yy_current_state];
                if (yy_current_state >= 825) yy_c = yy_meta[(unsigned int)yy_c];
            }
            yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
            ++yy_cp;
        } while (yy_base[yy_current_state] != 907);

    yy_find_action:
        yy_act = yy_accept[yy_current_state];
        if (yy_act == 0) { /* have to back up */
            yy_cp = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            yy_act = yy_accept[yy_current_state];
        }

        YY_DO_BEFORE_ACTION;

    do_action: /* This label is used only to access EOF actions. */

        switch (yy_act) { /* beginning of action switch */
        case 0:           /* must back up */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = yy_hold_char;
            yy_cp = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            goto yy_find_action;

        case 1: YY_RULE_SETUP
#line 53 "FlexMe.l"
            { /* delete white space */
            }
            YY_BREAK
        case 2: YY_RULE_SETUP
#line 54 "FlexMe.l"
            { /* increment line count */
                my_linecount++;
            }
            YY_BREAK
        case 3: YY_RULE_SETUP
#line 56 "FlexMe.l"
            { /* comment fprintf(stderr, "Comment: %s", my_linetext); */
                my_linecount++;
            }
            YY_BREAK
        case 4: YY_RULE_SETUP
#line 58 "FlexMe.l"
            return (TR_DEF);
            YY_BREAK
        case 5: YY_RULE_SETUP
#line 59 "FlexMe.l"
            return (TR_Separator);
            YY_BREAK
        case 6: YY_RULE_SETUP
#line 60 "FlexMe.l"
            return (TR_Separator);
            YY_BREAK
        case 7: YY_RULE_SETUP
#line 61 "FlexMe.l"
            return (TR_Separator);
            YY_BREAK
        case 8: YY_RULE_SETUP
#line 62 "FlexMe.l"
            return (TR_Separator);
            YY_BREAK
        case 9: YY_RULE_SETUP
#line 63 "FlexMe.l"
            return (TR_name);
            YY_BREAK
        case 10: YY_RULE_SETUP
#line 64 "FlexMe.l"
            return (TR_map);
            YY_BREAK
        case 11: YY_RULE_SETUP
#line 65 "FlexMe.l"
            return (TR_NONE);
            YY_BREAK
        case 12: YY_RULE_SETUP
#line 66 "FlexMe.l"
            return (TR_Info);
            YY_BREAK
        case 13: YY_RULE_SETUP
#line 67 "FlexMe.l"
            return (TR_string);
            YY_BREAK
        case 14: YY_RULE_SETUP
#line 68 "FlexMe.l"
            return (TR_PerspectiveCamera);
            YY_BREAK
        case 15: YY_RULE_SETUP
#line 69 "FlexMe.l"
            return (TR_position);
            YY_BREAK
        case 16: YY_RULE_SETUP
#line 70 "FlexMe.l"
            return (TR_orientation);
            YY_BREAK
        case 17: YY_RULE_SETUP
#line 71 "FlexMe.l"
            return (TR_focalDistance);
            YY_BREAK
        case 18: YY_RULE_SETUP
#line 72 "FlexMe.l"
            return (TR_heightAngle);
            YY_BREAK
        case 19: YY_RULE_SETUP
#line 73 "FlexMe.l"
            return (TR_MaterialBinding);
            YY_BREAK
        case 20: YY_RULE_SETUP
#line 74 "FlexMe.l"
            return (TR_NormalBinding);
            YY_BREAK
        case 21: YY_RULE_SETUP
#line 75 "FlexMe.l"
            return (TR_value);
            YY_BREAK
        case 22: YY_RULE_SETUP
#line 76 "FlexMe.l"
            return (TR_OVERALL);
            YY_BREAK
        case 23: YY_RULE_SETUP
#line 77 "FlexMe.l"
            return (TR_PER_FACE);
            YY_BREAK
        case 24: YY_RULE_SETUP
#line 78 "FlexMe.l"
            return (TR_PER_FACE_INDEXED);
            YY_BREAK
        case 25: YY_RULE_SETUP
#line 79 "FlexMe.l"
            return (TR_PER_VERTEX);
            YY_BREAK
        case 26: YY_RULE_SETUP
#line 80 "FlexMe.l"
            return (TR_PER_VERTEX_INDEXED);
            YY_BREAK
        case 27: YY_RULE_SETUP
#line 81 "FlexMe.l"
            return (TR_ShapeHints);
            YY_BREAK
        case 28: YY_RULE_SETUP
#line 82 "FlexMe.l"
            return (TR_vertexOrdering);
            YY_BREAK
        case 29: YY_RULE_SETUP
#line 83 "FlexMe.l"
            return (TR_COUNTERCLOCKWISE);
            YY_BREAK
        case 30: YY_RULE_SETUP
#line 84 "FlexMe.l"
            return (TR_CLOCKWISE);
            YY_BREAK
        case 31: YY_RULE_SETUP
#line 85 "FlexMe.l"
            return (TR_shapeType);
            YY_BREAK
        case 32: YY_RULE_SETUP
#line 86 "FlexMe.l"
            return (TR_SOLID);
            YY_BREAK
        case 33: YY_RULE_SETUP
#line 87 "FlexMe.l"
            return (TR_UNKNOWN_SHAPE_TYPE);
            YY_BREAK
        case 34: YY_RULE_SETUP
#line 88 "FlexMe.l"
            return (TR_faceType);
            YY_BREAK
        case 35: YY_RULE_SETUP
#line 89 "FlexMe.l"
            return (TR_CONVEX);
            YY_BREAK
        case 36: YY_RULE_SETUP
#line 90 "FlexMe.l"
            return (TR_creaseAngle);
            YY_BREAK
        case 37: YY_RULE_SETUP
#line 91 "FlexMe.l"
            return (TR_MatrixTransform);
            YY_BREAK
        case 38: YY_RULE_SETUP
#line 92 "FlexMe.l"
            return (TR_matrix);
            YY_BREAK
        case 39: YY_RULE_SETUP
#line 93 "FlexMe.l"
            return (TR_Scale);
            YY_BREAK
        case 40: YY_RULE_SETUP
#line 94 "FlexMe.l"
            return (TR_scaleFactor);
            YY_BREAK
        case 41: YY_RULE_SETUP
#line 95 "FlexMe.l"
            return (TR_Rotation);
            YY_BREAK
        case 42: YY_RULE_SETUP
#line 96 "FlexMe.l"
            return (TR_rotation);
            YY_BREAK
        case 43: YY_RULE_SETUP
#line 97 "FlexMe.l"
            return (TR_Translation);
            YY_BREAK
        case 44: YY_RULE_SETUP
#line 98 "FlexMe.l"
            return (TR_translation);
            YY_BREAK
        case 45: YY_RULE_SETUP
#line 99 "FlexMe.l"
            return (TR_Texture2Transform);
            YY_BREAK
        case 46: YY_RULE_SETUP
#line 100 "FlexMe.l"
            return (TR_center);
            YY_BREAK
        case 47: YY_RULE_SETUP
#line 101 "FlexMe.l"
            return (TR_renderCulling);
            YY_BREAK
        case 48: YY_RULE_SETUP
#line 102 "FlexMe.l"
            return (TR_ON);
            YY_BREAK
        case 49: YY_RULE_SETUP
#line 103 "FlexMe.l"
            return (TR_OFF);
            YY_BREAK
        case 50: YY_RULE_SETUP
#line 104 "FlexMe.l"
            return (TR_AUTO);
            YY_BREAK
        case 51: YY_RULE_SETUP
#line 105 "FlexMe.l"
            return (TR_TRUE);
            YY_BREAK
        case 52: YY_RULE_SETUP
#line 106 "FlexMe.l"
            return (TR_FALSE);
            YY_BREAK
        case 53: YY_RULE_SETUP
#line 107 "FlexMe.l"
            return (TR_Texture2);
            YY_BREAK
        case 54: YY_RULE_SETUP
#line 108 "FlexMe.l"
            return (TR_filename);
            YY_BREAK
        case 55: YY_RULE_SETUP
#line 109 "FlexMe.l"
            return (TR_Normal);
            YY_BREAK
        case 56: YY_RULE_SETUP
#line 110 "FlexMe.l"
            return (TR_vector);
            YY_BREAK
        case 57: YY_RULE_SETUP
#line 111 "FlexMe.l"
            return (TR_Coordinate3);
            YY_BREAK
        case 58: YY_RULE_SETUP
#line 112 "FlexMe.l"
            return (TR_point);
            YY_BREAK
        case 59: YY_RULE_SETUP
#line 113 "FlexMe.l"
            return (TR_Material);
            YY_BREAK
        case 60: YY_RULE_SETUP
#line 114 "FlexMe.l"
            return (TR_ambientColor);
            YY_BREAK
        case 61: YY_RULE_SETUP
#line 115 "FlexMe.l"
            return (TR_specularColor);
            YY_BREAK
        case 62: YY_RULE_SETUP
#line 116 "FlexMe.l"
            return (TR_emissiveColor);
            YY_BREAK
        case 63: YY_RULE_SETUP
#line 117 "FlexMe.l"
            return (TR_diffuseColor);
            YY_BREAK
        case 64: YY_RULE_SETUP
#line 118 "FlexMe.l"
            return (TR_shininess);
            YY_BREAK
        case 65: YY_RULE_SETUP
#line 119 "FlexMe.l"
            return (TR_transparency);
            YY_BREAK
        case 66: YY_RULE_SETUP
#line 120 "FlexMe.l"
            return (TR_TextureCoordinate2);
            YY_BREAK
        case 67: YY_RULE_SETUP
#line 121 "FlexMe.l"
            return (TR_IndexedFaceSet);
            YY_BREAK
        case 68: YY_RULE_SETUP
#line 122 "FlexMe.l"
            return (TR_coordIndex);
            YY_BREAK
        case 69: YY_RULE_SETUP
#line 123 "FlexMe.l"
            return (TR_materialIndex);
            YY_BREAK
        case 70: YY_RULE_SETUP
#line 124 "FlexMe.l"
            return (TR_normalIndex);
            YY_BREAK
        case 71: YY_RULE_SETUP
#line 125 "FlexMe.l"
            return (TR_textureCoordIndex);
            YY_BREAK
        case 72: YY_RULE_SETUP
#line 126 "FlexMe.l"
            return (TR_Cylinder);
            YY_BREAK
        case 73: YY_RULE_SETUP
#line 127 "FlexMe.l"
            return (TR_radius);
            YY_BREAK
        case 74: YY_RULE_SETUP
#line 128 "FlexMe.l"
            return (TR_Cube);
            YY_BREAK
        case 75: YY_RULE_SETUP
#line 129 "FlexMe.l"
            return (TR_width);
            YY_BREAK
        case 76: YY_RULE_SETUP
#line 130 "FlexMe.l"
            return (TR_height);
            YY_BREAK
        case 77: YY_RULE_SETUP
#line 131 "FlexMe.l"
            return (TR_depth);
            YY_BREAK
        case 78: YY_RULE_SETUP
#line 132 "FlexMe.l"
            return (TR_DirectionalLight);
            YY_BREAK
        case 79: YY_RULE_SETUP
#line 133 "FlexMe.l"
            return (TR_PointLight);
            YY_BREAK
        case 80: YY_RULE_SETUP
#line 134 "FlexMe.l"
            return (TR_SpotLight);
            YY_BREAK
        case 81: YY_RULE_SETUP
#line 135 "FlexMe.l"
            return (TR_color);
            YY_BREAK
        case 82: YY_RULE_SETUP
#line 136 "FlexMe.l"
            return (TR_intensity);
            YY_BREAK
        case 83: YY_RULE_SETUP
#line 137 "FlexMe.l"
            return (TR_direction);
            YY_BREAK
        case 84: YY_RULE_SETUP
#line 138 "FlexMe.l"
            return (TR_location);
            YY_BREAK
        case 85: YY_RULE_SETUP
#line 139 "FlexMe.l"
            return (TR_on);
            YY_BREAK
        case 86: YY_RULE_SETUP
#line 140 "FlexMe.l"
            return (TR_dropOffRate);
            YY_BREAK
        case 87: YY_RULE_SETUP
#line 141 "FlexMe.l"
            return (TR_cutOffAngle);
            YY_BREAK
        case 88: YY_RULE_SETUP
#line 143 "FlexMe.l"
            return (TR_RotationKey_ktx_com);
            YY_BREAK
        case 89: YY_RULE_SETUP
#line 144 "FlexMe.l"
            return (TR_AnimationFrames_ktx_com);
            YY_BREAK
        case 90: YY_RULE_SETUP
#line 145 "FlexMe.l"
            return (TR_ScaleKey_ktx_com);
            YY_BREAK
        case 91: YY_RULE_SETUP
#line 146 "FlexMe.l"
            return (TR_scale);
            YY_BREAK
        case 92: YY_RULE_SETUP
#line 147 "FlexMe.l"
            return (TR_fields);
            YY_BREAK
        case 93: YY_RULE_SETUP
#line 148 "FlexMe.l"
            return (TR_frame);
            YY_BREAK
        case 94: YY_RULE_SETUP
#line 149 "FlexMe.l"
            return (TR_AnimationStyle_ktx_com);
            YY_BREAK
        case 95: YY_RULE_SETUP
#line 150 "FlexMe.l"
            return (TR_splineUse);
            YY_BREAK
        case 96: YY_RULE_SETUP
#line 151 "FlexMe.l"
            return (TR_pivotOffset);
            YY_BREAK
        case 97: YY_RULE_SETUP
#line 152 "FlexMe.l"
            return (TR_PositionKey_ktx_com);
            YY_BREAK
        case 98: YY_RULE_SETUP
#line 153 "FlexMe.l"
            return (TR_AimTarget_ktx_com);
            YY_BREAK
        case 99: YY_RULE_SETUP
#line 154 "FlexMe.l"
            return (TR_aimer);
            YY_BREAK
        case 100: YY_RULE_SETUP
#line 155 "FlexMe.l"
            return (TR_length);
            YY_BREAK
        case 101: YY_RULE_SETUP
#line 156 "FlexMe.l"
            return (TR_rate);
            YY_BREAK
        case 102: YY_RULE_SETUP
#line 158 "FlexMe.l"
            {
                yylval.ival = VRML_ATOI(yytext);
                return (T_INT); /*integer literal */
            }
            YY_BREAK
        case 103: YY_RULE_SETUP
#line 161 "FlexMe.l"
            {
                /* Follow doesn't work on cystine:*/
                /* yylval.fval=VRML_ATOF(yytext); */
                sscanf(yytext, "%f", &(yylval.fval)); /* Used to be "%lf". I changed it to suppress a warning. */
                return (T_FLOAT);                     /*float literal */
            }
            YY_BREAK
        case 104: YY_RULE_SETUP
#line 167 "FlexMe.l"
            {
                yylval.sval = stripquotes();
                return (T_STRING);
            }
            YY_BREAK
        case 105: YY_RULE_SETUP
#line 170 "FlexMe.l"
            {
                yylval.sval = stripquotes();
                fprintf(stderr, "err:Run-on string\n");
                return (T_STRING);
            }
            YY_BREAK
        case 106: YY_RULE_SETUP
#line 174 "FlexMe.l"
            { /* brackets, comma */
                return (yytext[0]);
            }
            YY_BREAK
        case 107: YY_RULE_SETUP
#line 177 "FlexMe.l"
            {
                yylval.sval = strdup(yytext);

                /* fprintf(stderr, "%d Got a T_STRING: '%s'\n", yyleng, yylval.sval); */
                /* single-word identifier */ return (T_STRING);
            }
            YY_BREAK
        case 108: YY_RULE_SETUP
#line 182 "FlexMe.l"
            {
                fprintf(stderr, "Syntax Error (input line %i)\n", my_linecount);
                return (T_ERROR);
            }
            YY_BREAK
        case 109: YY_RULE_SETUP
#line 185 "FlexMe.l"
            ECHO;
            YY_BREAK
#line 1692 "lex.yy.c"
        case YY_STATE_EOF(INITIAL): yyterminate();

        case YY_END_OF_BUFFER: {
            /* Amount of text matched not including the EOB char. */
            int yy_amount_of_matched_text = (int)(yy_cp - yytext_ptr) - 1;

            /* Undo the effects of YY_DO_BEFORE_ACTION. */
            *yy_cp = yy_hold_char;
            YY_RESTORE_YY_MORE_OFFSET

            if (yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW) {
                /* We're scanning a new file or input source.  It's
                 * possible that this happened because the user
                 * just pointed yyin at a new source and called
                 * yylex().  If so, then we have to assure
                 * consistency between yy_current_buffer and our
                 * globals.  Here is the right place to do so, because
                 * this is the first action (other than possibly a
                 * back-up) that will match for the new input source.
                 */
                yy_n_chars = yy_current_buffer->yy_n_chars;
                yy_current_buffer->yy_input_file = yyin;
                yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
            }

            /* Note that here we test for yy_c_buf_p "<=" to the position
             * of the first EOB in the buffer, since yy_c_buf_p will
             * already have been incremented past the NUL character
             * (since all states make transitions on EOB to the
             * end-of-buffer state).  Contrast this with the test
             * in input().
             */
            if (yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars]) { /* This was really a NUL. */
                yy_state_type yy_next_state;

                yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                /* Okay, we're now positioned to make the NUL
                 * transition.  We couldn't have
                 * yy_get_previous_state() go ahead and do it
                 * for us because it doesn't know how to deal
                 * with the possibility of jamming (and we don't
                 * want to build jamming into it because then it
                 * will run more slowly).
                 */

                yy_next_state = yy_try_NUL_trans(yy_current_state);

                yy_bp = yytext_ptr + YY_MORE_ADJ;

                if (yy_next_state) {
                    /* Consume the NUL. */
                    yy_cp = ++yy_c_buf_p;
                    yy_current_state = yy_next_state;
                    goto yy_match;
                }

                else {
                    yy_cp = yy_c_buf_p;
                    goto yy_find_action;
                }
            }

            else
                switch (yy_get_next_buffer()) {
                case EOB_ACT_END_OF_FILE: {
                    yy_did_buffer_switch_on_eof = 0;

                    if (yywrap()) {
                        /* Note: because we've taken care in
                         * yy_get_next_buffer() to have set up
                         * yytext, we can now set up
                         * yy_c_buf_p so that if some total
                         * hoser (like flex itself) wants to
                         * call the scanner after we return the
                         * YY_NULL, it'll still work - another
                         * YY_NULL will get returned.
                         */
                        yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                        yy_act = YY_STATE_EOF(YY_START);
                        goto do_action;
                    }

                    else {
                        if (!yy_did_buffer_switch_on_eof) YY_NEW_FILE;
                    }
                    break;
                }

                case EOB_ACT_CONTINUE_SCAN:
                    yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

                    yy_current_state = yy_get_previous_state();

                    yy_cp = yy_c_buf_p;
                    yy_bp = yytext_ptr + YY_MORE_ADJ;
                    goto yy_match;

                case EOB_ACT_LAST_MATCH:
                    yy_c_buf_p = &yy_current_buffer->yy_ch_buf[yy_n_chars];

                    yy_current_state = yy_get_previous_state();

                    yy_cp = yy_c_buf_p;
                    yy_bp = yytext_ptr + YY_MORE_ADJ;
                    goto yy_find_action;
                }
            break;
        }

        default: YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
        } /* end of action switch */
    }     /* end of scanning one token */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
{
    register char* dest = yy_current_buffer->yy_ch_buf;
    register char* source = yytext_ptr;
    register int number_to_move, i;
    int ret_val;

    if (yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1]) YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

    if (yy_current_buffer->yy_fill_buffer == 0) { /* Don't try to fill the buffer, so this is an EOF. */
        if (yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1) {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
        }

        else {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
        }
    }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int)(yy_c_buf_p - yytext_ptr) - 1;

    for (i = 0; i < number_to_move; ++i) *(dest++) = *(source++);

    if (yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING)
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        yy_current_buffer->yy_n_chars = yy_n_chars = 0;

    else {
        int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;

        while (num_to_read <= 0) { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
            YY_FATAL_ERROR("input buffer overflow, can't enlarge buffer because scanner uses REJECT");
#else

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = yy_current_buffer;

            int yy_c_buf_p_offset = (int)(yy_c_buf_p - b->yy_ch_buf);

            if (b->yy_is_our_buffer) {
                int new_size = b->yy_buf_size * 2;

                if (new_size <= 0)
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char*)
                    /* Include room in for 2 EOB chars. */
                    yy_flex_realloc((void*)b->yy_ch_buf, b->yy_buf_size + 2);
            } else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = 0;

            if (!b->yy_ch_buf) YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

            yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;
#endif
        }

        if (num_to_read > YY_READ_BUF_SIZE) num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        YY_INPUT((&yy_current_buffer->yy_ch_buf[number_to_move]), yy_n_chars, num_to_read);

        yy_current_buffer->yy_n_chars = yy_n_chars;
    }

    if (yy_n_chars == 0) {
        if (number_to_move == YY_MORE_ADJ) {
            ret_val = EOB_ACT_END_OF_FILE;
            yyrestart(yyin);
        }

        else {
            ret_val = EOB_ACT_LAST_MATCH;
            yy_current_buffer->yy_buffer_status = YY_BUFFER_EOF_PENDING;
        }
    }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

    return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
{
    register yy_state_type yy_current_state;
    register char* yy_cp;

    yy_current_state = yy_start;

    for (yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp) {
        register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        if (yy_accept[yy_current_state]) {
            yy_last_accepting_state = yy_current_state;
            yy_last_accepting_cpos = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
            yy_current_state = (int)yy_def[yy_current_state];
            if (yy_current_state >= 825) yy_c = yy_meta[(unsigned int)yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
    }

    return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
#else
static yy_state_type yy_try_NUL_trans(yy_current_state) yy_state_type yy_current_state;
#endif
{
    register int yy_is_jam;
    register char* yy_cp = yy_c_buf_p;

    register YY_CHAR yy_c = 1;
    if (yy_accept[yy_current_state]) {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
        yy_current_state = (int)yy_def[yy_current_state];
        if (yy_current_state >= 825) yy_c = yy_meta[(unsigned int)yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
    yy_is_jam = (yy_current_state == 824);

    return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput(int c, register char* yy_bp)
#else
static void yyunput(c, yy_bp) int c;
register char* yy_bp;
#endif
{
    register char* yy_cp = yy_c_buf_p;

    /* undo effects of setting up yytext */
    *yy_cp = yy_hold_char;

    if (yy_cp < yy_current_buffer->yy_ch_buf + 2) { /* need to shift things up to make room */
        /* +2 for EOB chars. */
        register int number_to_move = yy_n_chars + 2;
        register char* dest = &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
        register char* source = &yy_current_buffer->yy_ch_buf[number_to_move];

        while (source > yy_current_buffer->yy_ch_buf) *--dest = *--source;

        yy_cp += (int)(dest - source);
        yy_bp += (int)(dest - source);
        yy_current_buffer->yy_n_chars = yy_n_chars = yy_current_buffer->yy_buf_size;

        if (yy_cp < yy_current_buffer->yy_ch_buf + 2) YY_FATAL_ERROR("flex scanner push-back overflow");
    }

    *--yy_cp = (char)c;

    yytext_ptr = yy_bp;
    yy_hold_char = *yy_cp;
    yy_c_buf_p = yy_cp;
}
#endif /* ifndef YY_NO_UNPUT */

#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
{
    int c;
    static int _xpg = -1;

    if (_xpg == -1) {
        char* _xpgenv = getenv("_XPG");
        if (_xpgenv == NULL)
            _xpg = 0;
        else {
            _xpg = atoi(_xpgenv);
            if (_xpg < 0) _xpg = 0;
        }
    }

    *yy_c_buf_p = yy_hold_char;

    if (*yy_c_buf_p == YY_END_OF_BUFFER_CHAR) {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if (yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars]) /* This was really a NUL. */
            *yy_c_buf_p = '\0';

        else { /* need more input */
            int offset = yy_c_buf_p - yytext_ptr;
            ++yy_c_buf_p;

            switch (yy_get_next_buffer()) {
            case EOB_ACT_LAST_MATCH:
                /* This happens because yy_g_n_b()
                 * sees that we've accumulated a
                 * token and flags that we need to
                 * try matching the token before
                 * proceeding.  But for input(),
                 * there's no matching to consider.
                 * So convert the EOB_ACT_LAST_MATCH
                 * to EOB_ACT_END_OF_FILE.
                 */

                /* Reset buffer status. */
                yyrestart(yyin);

                /* fall through */

            case EOB_ACT_END_OF_FILE:
                if (_xpg)
                    return 0;
                else {
                    if (yywrap()) return 0;

                    if (!yy_did_buffer_switch_on_eof) YY_NEW_FILE;
#ifdef __cplusplus
                    return yyinput();
#else
                    return input();
#endif
                }

            case EOB_ACT_CONTINUE_SCAN: yy_c_buf_p = yytext_ptr + offset; break;
            }
        }
    }

    c = *(unsigned char*)yy_c_buf_p; /* cast for 8-bit char's */
    *yy_c_buf_p = '\0';              /* preserve yytext */
    yy_hold_char = *++yy_c_buf_p;

    return c;
}

#ifdef YY_USE_PROTOS
void yyrestart(FILE* input_file)
#else
void yyrestart(input_file) FILE* input_file;
#endif
{
    if (!yy_current_buffer) yy_current_buffer = yy_create_buffer(yyin, YY_BUF_SIZE);

    yy_init_buffer(yy_current_buffer, input_file);
    yy_load_buffer_state();
}

#ifdef YY_USE_PROTOS
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
#else
void yy_switch_to_buffer(new_buffer) YY_BUFFER_STATE new_buffer;
#endif
{
    if (yy_current_buffer == new_buffer) return;

    if (yy_current_buffer) {
        /* Flush out information for old buffer. */
        *yy_c_buf_p = yy_hold_char;
        yy_current_buffer->yy_buf_pos = yy_c_buf_p;
        yy_current_buffer->yy_n_chars = yy_n_chars;
    }

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
}

#ifdef YY_USE_PROTOS
void yy_load_buffer_state(void)
#else
void yy_load_buffer_state()
#endif
{
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
}

#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size)
#else
YY_BUFFER_STATE yy_create_buffer(file, size) FILE* file;
int size;
#endif
{
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE)yy_flex_alloc(sizeof(struct yy_buffer_state));
    if (!b) YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char*)yy_flex_alloc(b->yy_buf_size + 2);
    if (!b->yy_ch_buf) YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_is_our_buffer = 1;

    yy_init_buffer(b, file);

    return b;
}

#ifdef YY_USE_PROTOS
void yy_delete_buffer(YY_BUFFER_STATE b)
#else
void yy_delete_buffer(b) YY_BUFFER_STATE b;
#endif
{
    if (!b) return;

    if (b == yy_current_buffer) yy_current_buffer = (YY_BUFFER_STATE)0;

    if (b->yy_is_our_buffer) yy_flex_free((void*)b->yy_ch_buf);

    yy_flex_free((void*)b);
}

#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO((int));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer(YY_BUFFER_STATE b, FILE* file)
#else
void yy_init_buffer(b, file) YY_BUFFER_STATE b;
FILE* file;
#endif

{
    yy_flush_buffer(b);

    b->yy_input_file = file;
    b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
    b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
    b->yy_is_interactive = 0;
#else
    b->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;
#endif
#endif
}

#ifdef YY_USE_PROTOS
void yy_flush_buffer(YY_BUFFER_STATE b)
#else
void yy_flush_buffer(b) YY_BUFFER_STATE b;
#endif

{
    if (!b) return;

    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if (b == yy_current_buffer) yy_load_buffer_state();
}

#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size)
#else
YY_BUFFER_STATE yy_scan_buffer(base, size) char* base;
yy_size_t size;
#endif
{
    YY_BUFFER_STATE b;

    if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR || base[size - 1] != YY_END_OF_BUFFER_CHAR) /* They forgot to leave room for the EOB's. */
        return 0;

    b = (YY_BUFFER_STATE)yy_flex_alloc(sizeof(struct yy_buffer_state));
    if (!b) YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

    b->yy_buf_size = size - 2; /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = 0;
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = YY_BUFFER_NEW;

    yy_switch_to_buffer(b);

    return b;
}
#endif

#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string(yyconst char* yy_str)
#else
YY_BUFFER_STATE yy_scan_string(yy_str) yyconst char* yy_str;
#endif
{
    int len;
    for (len = 0; yy_str[len]; ++len)
        ;

    return yy_scan_bytes(yy_str, len);
}
#endif

#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes(yyconst char* bytes, int len)
#else
YY_BUFFER_STATE yy_scan_bytes(bytes, len) yyconst char* bytes;
int len;
#endif
{
    YY_BUFFER_STATE b;
    char* buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n = len + 2;
    buf = (char*)yy_flex_alloc(n);
    if (!buf) YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

    for (i = 0; i < len; ++i) buf[i] = bytes[i];

    buf[len] = buf[len + 1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer(buf, n);
    if (!b) YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
}
#endif

#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state(int new_state)
#else
static void yy_push_state(new_state) int new_state;
#endif
{
    if (yy_start_stack_ptr >= yy_start_stack_depth) {
        yy_size_t new_size;

        yy_start_stack_depth += YY_START_STACK_INCR;
        new_size = yy_start_stack_depth * sizeof(int);

        if (!yy_start_stack)
            yy_start_stack = (int*)yy_flex_alloc(new_size);

        else
            yy_start_stack = (int*)yy_flex_realloc((void*)yy_start_stack, new_size);

        if (!yy_start_stack) YY_FATAL_ERROR("out of memory expanding start-condition stack");
    }

    yy_start_stack[yy_start_stack_ptr++] = YY_START;

    BEGIN(new_state);
}
#endif

#ifndef YY_NO_POP_STATE
static void yy_pop_state()
{
    if (--yy_start_stack_ptr < 0) YY_FATAL_ERROR("start-condition stack underflow");

    BEGIN(yy_start_stack[yy_start_stack_ptr]);
}
#endif

#ifndef YY_NO_TOP_STATE
static int yy_top_state() { return yy_start_stack[yy_start_stack_ptr - 1]; }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error(yyconst char msg[])
#else
static void yy_fatal_error(msg) char msg[];
#endif
{
    (void)fprintf(stderr, "%s\n", msg);
    exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                \
    do {                                         \
        /* Undo effects of setting up yytext. */ \
        yytext[yyleng] = yy_hold_char;           \
        yy_c_buf_p = yytext + n;                 \
        yy_hold_char = *yy_c_buf_p;              \
        *yy_c_buf_p = '\0';                      \
        yyleng = n;                              \
    } while (0)

/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy(char* s1, yyconst char* s2, int n)
#else
static void yy_flex_strncpy(s1, s2, n) char* s1;
yyconst char* s2;
int n;
#endif
{
    register int i;
    for (i = 0; i < n; ++i) s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen(yyconst char* s)
#else
static int yy_flex_strlen(s) yyconst char* s;
#endif
{
    register int n;
    for (n = 0; s[n]; ++n)
        ;

    return n;
}
#endif

#ifdef YY_USE_PROTOS
static void* yy_flex_alloc(yy_size_t size)
#else
static void* yy_flex_alloc(size) yy_size_t size;
#endif
{
    return (void*)malloc(size);
}

#ifdef YY_USE_PROTOS
static void* yy_flex_realloc(void* ptr, yy_size_t size)
#else
static void* yy_flex_realloc(ptr, size) void* ptr;
yy_size_t size;
#endif
{
    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return (void*)realloc((char*)ptr, size);
}

#ifdef YY_USE_PROTOS
static void yy_flex_free(void* ptr)
#else
static void yy_flex_free(ptr) void* ptr;
#endif
{
    free(ptr);
}

#if YY_MAIN
int main()
{
    yylex();
    return 0;
}
#endif
#line 185 "FlexMe.l"

/* Strip unwanted quotes from string in yytext,
   reduce "" to ".
   Shamelessly cribbed from Crafting a compiler with C, pg. 67
   Modified to produce \" instead of ", and \\ instead of \
*/
char* stripquotes(void)
{
    char* result;
    int frompos, topos = 0;

    result = (char*)malloc(yyleng * 2); /* big enough for all backslash */
    if (result == NULL) {
        fprintf(stderr, "stripquotes: malloc() failed\n");
        exit(1);
    }
    for (frompos = 1; frompos < (yyleng - 1); frompos++) {
        if (yytext[frompos] == '\\') {
            result[topos++] = '\\';
        } else if ((yytext[frompos] == '"') && (yytext[frompos + 1] == '"')) {
            result[topos++] = '\\';
            frompos++;
        }
        result[topos++] = yytext[frompos];
    }
    result[topos] = '\0';
    return (result);
}

/*
 * return pointer to yytext
 * called by bison code
 */
char* tokentext(void) { return (yytext); }
